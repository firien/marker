/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.js\");\n/* harmony import */ var marked__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(marked__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var diff_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! diff-dom */ \"./node_modules/diff-dom/diffDOM.js\");\n/* harmony import */ var diff_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(diff_dom__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nwindow.marked = marked__WEBPACK_IMPORTED_MODULE_0___default.a\nwindow.diffDOM = diff_dom__WEBPACK_IMPORTED_MODULE_1___default.a\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ }),

/***/ "./node_modules/diff-dom/diffDOM.js":
/*!******************************************!*\
  !*** ./node_modules/diff-dom/diffDOM.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(root, factory) {\n    if (true) {\n        if ( true && module.exports) {\n            exports = module.exports = factory();\n        } else {\n            exports.diffDOM = factory();\n        }\n    } else {}\n})(this, function() {\n    \"use strict\";\n\n    var diffcount, foundAll = false;\n\n    var Diff = function(options) {\n        var diff = this;\n        if (options) {\n            var keys = Object.keys(options),\n                length = keys.length,\n                i;\n            for (i = 0; i < length; i++) {\n                diff[keys[i]] = options[keys[i]];\n            }\n        }\n\n    };\n\n    Diff.prototype = {\n        toString: function() {\n            return JSON.stringify(this);\n        },\n        setValue: function(aKey, aValue) {\n            this[aKey] = aValue;\n            return this;\n        }\n    };\n\n\n\n    var elementDescriptors = function(el) {\n        var output = [];\n        if (el.nodeName !== '#text' && el.nodeName !== '#comment') {\n            output.push(el.nodeName);\n            if (el.attributes) {\n                if (el.attributes['class']) {\n                    output.push(el.nodeName + '.' + el.attributes['class'].replace(/ /g, '.'));\n                }\n                if (el.attributes.id) {\n                    output.push(el.nodeName + '#' + el.attributes.id);\n                }\n            }\n\n        }\n        return output;\n    };\n\n    var findUniqueDescriptors = function(li) {\n        var uniqueDescriptors = {},\n            duplicateDescriptors = {},\n            liLength = li.length,\n            descriptorsLength, node, descriptors, descriptor, inUnique, inDupes, i, j;\n\n        for (i = 0; i < liLength; i++) {\n            node = li[i];\n            descriptors = elementDescriptors(node);\n            descriptorsLength = descriptors.length;\n            for (j = 0; j < descriptorsLength; j++) {\n                descriptor = descriptors[j];\n                inUnique = descriptor in uniqueDescriptors;\n                inDupes = descriptor in duplicateDescriptors;\n                if (!inUnique && !inDupes) {\n                    uniqueDescriptors[descriptor] = true;\n                } else if (inUnique) {\n                    delete uniqueDescriptors[descriptor];\n                    duplicateDescriptors[descriptor] = true;\n                }\n            }\n        }\n\n        return uniqueDescriptors;\n    };\n\n    var uniqueInBoth = function(l1, l2) {\n        var l1Unique = findUniqueDescriptors(l1),\n            l2Unique = findUniqueDescriptors(l2),\n            inBoth = {},\n            keys = Object.keys(l1Unique),\n            length = keys.length,\n            key,\n            i;\n\n        for (i = 0; i < length; i++) {\n            key = keys[i];\n            if (l2Unique[key]) {\n                inBoth[key] = true;\n            }\n        }\n\n        return inBoth;\n    };\n\n    var removeDone = function(tree) {\n        delete tree.outerDone;\n        delete tree.innerDone;\n        delete tree.valueDone;\n        if (tree.childNodes) {\n            return tree.childNodes.every(removeDone);\n        } else {\n            return true;\n        }\n    };\n\n    var isEqual = function(e1, e2) {\n\n        var e1Attributes, e2Attributes;\n\n        if (!['nodeName', 'value', 'checked', 'selected', 'data'].every(function(element) {\n                if (e1[element] !== e2[element]) {\n                    return false;\n                }\n                return true;\n            })) {\n            return false;\n        }\n\n        if (Boolean(e1.attributes) !== Boolean(e2.attributes)) {\n            return false;\n        }\n\n        if (Boolean(e1.childNodes) !== Boolean(e2.childNodes)) {\n            return false;\n        }\n        if (e1.attributes) {\n            e1Attributes = Object.keys(e1.attributes);\n            e2Attributes = Object.keys(e2.attributes);\n\n            if (e1Attributes.length !== e2Attributes.length) {\n                return false;\n            }\n            if (!e1Attributes.every(function(attribute) {\n                    if (e1.attributes[attribute] !== e2.attributes[attribute]) {\n                        return false;\n                    }\n                    return true;\n                })) {\n                return false;\n            }\n        }\n        if (e1.childNodes) {\n            if (e1.childNodes.length !== e2.childNodes.length) {\n                return false;\n            }\n            if (!e1.childNodes.every(function(childNode, index) {\n                    return isEqual(childNode, e2.childNodes[index]);\n                })) {\n\n                return false;\n            }\n\n        }\n\n        return true;\n\n    };\n\n\n    var roughlyEqual = function(e1, e2, uniqueDescriptors, sameSiblings, preventRecursion) {\n        var childUniqueDescriptors, nodeList1, nodeList2;\n\n        if (!e1 || !e2) {\n            return false;\n        }\n\n        if (e1.nodeName !== e2.nodeName) {\n            return false;\n        }\n\n        if (e1.nodeName === '#text') {\n            // Note that we initially don't care what the text content of a node is,\n            // the mere fact that it's the same tag and \"has text\" means it's roughly\n            // equal, and then we can find out the true text difference later.\n            return preventRecursion ? true : e1.data === e2.data;\n        }\n\n\n        if (e1.nodeName in uniqueDescriptors) {\n            return true;\n        }\n\n        if (e1.attributes && e2.attributes) {\n\n            if (e1.attributes.id) {\n                if (e1.attributes.id !== e2.attributes.id) {\n                    return false;\n                } else {\n                    var idDescriptor = e1.nodeName + '#' + e1.attributes.id;\n                    if (idDescriptor in uniqueDescriptors) {\n                        return true;\n                    }\n                }\n            }\n            if (e1.attributes['class'] && e1.attributes['class'] === e2.attributes['class']) {\n                var classDescriptor = e1.nodeName + '.' + e1.attributes['class'].replace(/ /g, '.');\n                if (classDescriptor in uniqueDescriptors) {\n                    return true;\n                }\n            }\n        }\n\n        if (sameSiblings) {\n            return true;\n        }\n\n        nodeList1 = e1.childNodes ? e1.childNodes.slice().reverse() : [];\n        nodeList2 = e2.childNodes ? e2.childNodes.slice().reverse() : [];\n\n        if (nodeList1.length !== nodeList2.length) {\n            return false;\n        }\n\n        if (preventRecursion) {\n            return nodeList1.every(function(element, index) {\n                return element.nodeName === nodeList2[index].nodeName;\n            });\n        } else {\n            // note: we only allow one level of recursion at any depth. If 'preventRecursion'\n            // was not set, we must explicitly force it to true for child iterations.\n            childUniqueDescriptors = uniqueInBoth(nodeList1, nodeList2);\n            return nodeList1.every(function(element, index) {\n                return roughlyEqual(element, nodeList2[index], childUniqueDescriptors, true, true);\n            });\n        }\n    };\n\n\n    var cloneObj = function(obj) {\n        //  TODO: Do we really need to clone here? Is it not enough to just return the original object?\n        return JSON.parse(JSON.stringify(obj));\n    };\n\n    /**\n     * based on https://en.wikibooks.org/wiki/Algorithm_implementation/Strings/Longest_common_substring#JavaScript\n     */\n    var findCommonSubsets = function(c1, c2, marked1, marked2) {\n        var lcsSize = 0,\n            index = [],\n            c1Length = c1.length,\n            c2Length = c2.length,\n            matches = Array.apply(null, new Array(c1Length + 1)).map(function() {\n                return [];\n            }), // set up the matching table\n            uniqueDescriptors = uniqueInBoth(c1, c2),\n            // If all of the elements are the same tag, id and class, then we can\n            // consider them roughly the same even if they have a different number of\n            // children. This will reduce removing and re-adding similar elements.\n            subsetsSame = c1Length === c2Length,\n            origin, ret, c1Index, c2Index, c1Element, c2Element;\n\n        if (subsetsSame) {\n\n            c1.some(function(element, i) {\n                var c1Desc = elementDescriptors(element),\n                    c2Desc = elementDescriptors(c2[i]);\n                if (c1Desc.length !== c2Desc.length) {\n                    subsetsSame = false;\n                    return true;\n                }\n                c1Desc.some(function(description, i) {\n                    if (description !== c2Desc[i]) {\n                        subsetsSame = false;\n                        return true;\n                    }\n                });\n                if (!subsetsSame) {\n                    return true;\n                }\n\n            });\n        }\n\n        // fill the matches with distance values\n        for (c1Index = 0; c1Index < c1Length; c1Index++) {\n            c1Element = c1[c1Index];\n            for (c2Index = 0; c2Index < c2Length; c2Index++) {\n                c2Element = c2[c2Index];\n                if (!marked1[c1Index] && !marked2[c2Index] && roughlyEqual(c1Element, c2Element, uniqueDescriptors, subsetsSame)) {\n                    matches[c1Index + 1][c2Index + 1] = (matches[c1Index][c2Index] ? matches[c1Index][c2Index] + 1 : 1);\n                    if (matches[c1Index + 1][c2Index + 1] >= lcsSize) {\n                        lcsSize = matches[c1Index + 1][c2Index + 1];\n                        index = [c1Index + 1, c2Index + 1];\n                    }\n                } else {\n                    matches[c1Index + 1][c2Index + 1] = 0;\n                }\n            }\n        }\n\n        if (lcsSize === 0) {\n            return false;\n        }\n\n        return {\n            oldValue: index[0] - lcsSize,\n            newValue: index[1] - lcsSize,\n            length: lcsSize\n        };\n    };\n\n    /**\n     * This should really be a predefined function in Array...\n     */\n    var makeArray = function(n, v) {\n        return Array.apply(null, new Array(n)).map(function() {\n            return v;\n        });\n    };\n\n    /**\n     * Generate arrays that indicate which node belongs to which subset,\n     * or whether it's actually an orphan node, existing in only one\n     * of the two trees, rather than somewhere in both.\n     *\n     * So if t1 = <img><canvas><br>, t2 = <canvas><br><img>.\n     * The longest subset is \"<canvas><br>\" (length 2), so it will group 0.\n     * The second longest is \"<img>\" (length 1), so it will be group 1.\n     * gaps1 will therefore be [1,0,0] and gaps2 [0,0,1].\n     *\n     * If an element is not part of any group, it will stay being 'true', which\n     * is the initial value. For example:\n     * t1 = <img><p></p><br><canvas>, t2 = <b></b><br><canvas><img>\n     *\n     * The \"<p></p>\" and \"<b></b>\" do only show up in one of the two and will\n     * therefore be marked by \"true\". The remaining parts are parts of the\n     * groups 0 and 1:\n     * gaps1 = [1, true, 0, 0], gaps2 = [true, 0, 0, 1]\n     *\n     */\n    var getGapInformation = function(t1, t2, stable) {\n\n        var gaps1 = t1.childNodes ? makeArray(t1.childNodes.length, true) : [],\n            gaps2 = t2.childNodes ? makeArray(t2.childNodes.length, true) : [],\n            group = 0,\n            length = stable.length,\n            i, j, endOld, endNew, subset;\n\n        // give elements from the same subset the same group number\n        for (i = 0; i < length; i++) {\n            subset = stable[i];\n            endOld = subset.oldValue + subset.length;\n            endNew = subset.newValue + subset.length;\n            for (j = subset.oldValue; j < endOld; j += 1) {\n                gaps1[j] = group;\n            }\n            for (j = subset.newValue; j < endNew; j += 1) {\n                gaps2[j] = group;\n            }\n            group += 1;\n        }\n\n        return {\n            gaps1: gaps1,\n            gaps2: gaps2\n        };\n    };\n\n    /**\n     * Find all matching subsets, based on immediate child differences only.\n     */\n    var markSubTrees = function(oldTree, newTree) {\n        // note: the child lists are views, and so update as we update old/newTree\n        var oldChildren = oldTree.childNodes ? oldTree.childNodes : [],\n            newChildren = newTree.childNodes ? newTree.childNodes : [],\n            marked1 = makeArray(oldChildren.length, false),\n            marked2 = makeArray(newChildren.length, false),\n            subsets = [],\n            subset = true,\n            returnIndex = function() {\n                return arguments[1];\n            },\n            markBoth = function(i) {\n                marked1[subset.oldValue + i] = true;\n                marked2[subset.newValue + i] = true;\n            },\n            length, subsetArray, i;\n\n        while (subset) {\n            subset = findCommonSubsets(oldChildren, newChildren, marked1, marked2);\n            if (subset) {\n                subsets.push(subset);\n                subsetArray = Array.apply(null, new Array(subset.length)).map(returnIndex);\n                length = subsetArray.length;\n                for (i = 0; i < length; i++) {\n                    markBoth(subsetArray[i]);\n                }\n            }\n        }\n\n        oldTree.subsets = subsets;\n        oldTree.subsetsAge = 100;\n        return subsets;\n    };\n\n\n    function swap(obj, p1, p2) {\n        var tmp = obj[p1];\n        obj[p1] = obj[p2];\n        obj[p2] = tmp;\n    }\n\n\n    var DiffTracker = function() {\n        this.list = [];\n    };\n\n    DiffTracker.prototype = {\n        list: false,\n        add: function(diffs) {\n            this.list.push.apply(this.list, diffs);\n        },\n        forEach: function(fn) {\n            var length = this.list.length,\n                i;\n            for (i = 0; i < length; i++) {\n                fn(this.list[i]);\n            }\n        }\n    };\n\n    var diffDOM = function(options) {\n\n        var defaults = {\n                debug: false,\n                diffcap: 10, // Limit for how many diffs are accepting when debugging. Inactive when debug is false.\n                maxDepth: false, // False or a numeral. If set to a numeral, limits the level of depth that the the diff mechanism looks for differences. If false, goes through the entire tree.\n                maxChildCount: 50, // False or a numeral. If set to a numeral, does not try to diff the contents of nodes with more children if there are more than maxChildDiffCount differences among child nodes.\n                maxChildDiffCount: 3, // Numeral. See maxChildCount.\n                valueDiffing: true, // Whether to take into consideration the values of forms that differ from auto assigned values (when a user fills out a form).\n                // syntax: textDiff: function (node, currentValue, expectedValue, newValue)\n                textDiff: function() {\n                    arguments[0].data = arguments[3];\n                    return;\n                },\n                // empty functions were benchmarked as running faster than both\n                // `f && f()` and `if (f) { f(); }`\n                preVirtualDiffApply: function() {},\n                postVirtualDiffApply: function() {},\n                preDiffApply: function() {},\n                postDiffApply: function() {},\n                filterOuterDiff: null,\n                compress: false // Whether to work with compressed diffs\n            },\n            varNames, i, j;\n\n        if (typeof options === \"undefined\") {\n            options = {};\n        }\n\n        for (i in defaults) {\n            if (typeof options[i] === \"undefined\") {\n                this[i] = defaults[i];\n            } else {\n                this[i] = options[i];\n            }\n        }\n\n        var varNames = {\n            'addAttribute': 'addAttribute',\n            'modifyAttribute': 'modifyAttribute',\n            'removeAttribute': 'removeAttribute',\n            'modifyTextElement': 'modifyTextElement',\n            'relocateGroup': 'relocateGroup',\n            'removeElement': 'removeElement',\n            'addElement': 'addElement',\n            'removeTextElement': 'removeTextElement',\n            'addTextElement': 'addTextElement',\n            'replaceElement': 'replaceElement',\n            'modifyValue': 'modifyValue',\n            'modifyChecked': 'modifyChecked',\n            'modifySelected': 'modifySelected',\n            'modifyComment': 'modifyComment',\n            'action': 'action',\n            'route': 'route',\n            'oldValue': 'oldValue',\n            'newValue': 'newValue',\n            'element': 'element',\n            'group': 'group',\n            'from': 'from',\n            'to': 'to',\n            'name': 'name',\n            'value': 'value',\n            'data': 'data',\n            'attributes': 'attributes',\n            'nodeName': 'nodeName',\n            'childNodes': 'childNodes',\n            'checked': 'checked',\n            'selected': 'selected'\n        };\n\n        if (this.compress) {\n            j = 0;\n            this._const = {};\n            for (i in varNames) {\n                this._const[i] = j;\n                j++;\n            }\n        } else {\n            this._const = varNames;\n        }\n    };\n\n    diffDOM.Diff = Diff;\n\n    diffDOM.prototype = {\n\n        // ===== Create a diff =====\n\n        diff: function(t1Node, t2Node) {\n\n            var t1 = this.nodeToObj(t1Node),\n                t2 = this.nodeToObj(t2Node);\n\n            diffcount = 0;\n\n            if (this.debug) {\n                this.t1Orig = this.nodeToObj(t1Node);\n                this.t2Orig = this.nodeToObj(t2Node);\n            }\n\n            this.tracker = new DiffTracker();\n            return this.findDiffs(t1, t2);\n        },\n        findDiffs: function(t1, t2) {\n            var diffs;\n            do {\n                if (this.debug) {\n                    diffcount += 1;\n                    if (diffcount > this.diffcap) {\n                        window.diffError = [this.t1Orig, this.t2Orig];\n                        throw new Error(\"surpassed diffcap:\" + JSON.stringify(this.t1Orig) + \" -> \" + JSON.stringify(this.t2Orig));\n                    }\n                }\n                diffs = this.findNextDiff(t1, t2, []);\n\n                if (diffs.length === 0) {\n                    // Last check if the elements really are the same now.\n                    // If not, remove all info about being done and start over.\n                    // Sometimes a node can be marked as done, but the creation of subsequent diffs means that it has to be changed again.\n                    if (!isEqual(t1, t2)) {\n                        if (foundAll) {\n                            console.error('Could not find remaining diffs!');\n                            console.log(t1);\n                            console.log(t2);\n                        } else {\n                            foundAll = true;\n                            removeDone(t1);\n                            diffs = this.findNextDiff(t1, t2, []);\n                        }\n                    }\n                }\n                if (diffs.length > 0) {\n                    foundAll = false\n                    this.tracker.add(diffs);\n                    this.applyVirtual(t1, diffs);\n                }\n            } while (diffs.length > 0);\n            return this.tracker.list;\n        },\n        findNextDiff: function(t1, t2, route) {\n            var diffs, fdiffs;\n\n            if (this.maxDepth && route.length > this.maxDepth) {\n                return [];\n            }\n            // outer differences?\n            if (!t1.outerDone) {\n                diffs = this.findOuterDiff(t1, t2, route);\n                if (this.filterOuterDiff) {\n                    fdiffs = this.filterOuterDiff(t1, t2, diffs);\n                    if (fdiffs) diffs = fdiffs;\n                }\n                if (diffs.length > 0) {\n                    t1.outerDone = true;\n                    return diffs;\n                } else {\n                    t1.outerDone = true;\n                }\n            }\n            // inner differences?\n            if (!t1.innerDone) {\n                diffs = this.findInnerDiff(t1, t2, route);\n                if (diffs.length > 0) {\n                    return diffs;\n                } else {\n                    t1.innerDone = true;\n                }\n            }\n\n            if (this.valueDiffing && !t1.valueDone) {\n                // value differences?\n                diffs = this.findValueDiff(t1, t2, route);\n\n                if (diffs.length > 0) {\n                    t1.valueDone = true;\n                    return diffs;\n                } else {\n                    t1.valueDone = true;\n                }\n            }\n\n            // no differences\n            return [];\n        },\n        findOuterDiff: function(t1, t2, route) {\n            var t = this;\n            var diffs = [],\n                attr,\n                attr1, attr2, attrLength, pos, i;\n\n            if (t1.nodeName !== t2.nodeName) {\n                return [new Diff()\n                    .setValue(t._const.action, t._const.replaceElement)\n                    .setValue(t._const.oldValue, cloneObj(t1))\n                    .setValue(t._const.newValue, cloneObj(t2))\n                    .setValue(t._const.route, route)\n                ];\n            }\n\n            if (route.length && this.maxChildCount && t1.childNodes && t2.childNodes && t1.childNodes.length >  this.maxChildCount && t2.childNodes.length > this.maxChildCount) {\n                var childNodesLength = t1.childNodes.length < t2.childNodes.length ? t1.childNodes.length : t2.childNodes.length, childDiffCount = 0,  j = 0;\n                while (childDiffCount < this.maxChildDiffCount && j < childNodesLength) {\n                    if (!isEqual(t1.childNodes[j], t2.childNodes[j])) {\n                        childDiffCount++;\n                    }\n                    j++;\n                }\n                if (childDiffCount === this.maxChildDiffCount) {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.replaceElement)\n                        .setValue(t._const.oldValue, cloneObj(t1))\n                        .setValue(t._const.newValue, cloneObj(t2))\n                        .setValue(t._const.route, route)\n                    ];\n                }\n            }\n\n            if (t1.data !== t2.data) {\n                // Comment or text node.\n                if (t1.nodeName === '#text') {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.modifyTextElement)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.oldValue, t1.data)\n                        .setValue(t._const.newValue, t2.data)\n                    ];\n                } else {\n                    return [new Diff()\n                        .setValue(t._const.action, t._const.modifyComment)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.oldValue, t1.data)\n                        .setValue(t._const.newValue, t2.data)\n                    ];\n                }\n\n            }\n\n\n            attr1 = t1.attributes ? Object.keys(t1.attributes).sort() : [];\n            attr2 = t2.attributes ? Object.keys(t2.attributes).sort() : [];\n\n            attrLength = attr1.length;\n            for (i = 0; i < attrLength; i++) {\n                attr = attr1[i];\n                pos = attr2.indexOf(attr);\n                if (pos === -1) {\n                    diffs.push(new Diff()\n                        .setValue(t._const.action, t._const.removeAttribute)\n                        .setValue(t._const.route, route)\n                        .setValue(t._const.name, attr)\n                        .setValue(t._const.value, t1.attributes[attr])\n                    );\n                } else {\n                    attr2.splice(pos, 1);\n                    if (t1.attributes[attr] !== t2.attributes[attr]) {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.modifyAttribute)\n                            .setValue(t._const.route, route)\n                            .setValue(t._const.name, attr)\n                            .setValue(t._const.oldValue, t1.attributes[attr])\n                            .setValue(t._const.newValue, t2.attributes[attr])\n                        );\n                    }\n                }\n            }\n\n            attrLength = attr2.length;\n            for (i = 0; i < attrLength; i++) {\n                attr = attr2[i];\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.addAttribute)\n                    .setValue(t._const.route, route)\n                    .setValue(t._const.name, attr)\n                    .setValue(t._const.value, t2.attributes[attr])\n                );\n            }\n\n            return diffs;\n        },\n        nodeToObj: function(aNode) {\n            var objNode = {},\n                dobj = this,\n                nodeArray, childNode, length, attribute, i;\n            objNode.nodeName = aNode.nodeName;\n            if (objNode.nodeName === '#text' || objNode.nodeName === '#comment') {\n                objNode.data = aNode.data;\n            } else {\n                if (aNode.attributes && aNode.attributes.length > 0) {\n                    objNode.attributes = {};\n                    nodeArray = Array.prototype.slice.call(aNode.attributes);\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        attribute = nodeArray[i];\n                        objNode.attributes[attribute.name] = attribute.value;\n                    }\n                }\n                if (objNode.nodeName === 'TEXTAREA') {\n                    objNode.value = aNode.value;\n                } else if (aNode.childNodes && aNode.childNodes.length > 0) {\n                    objNode.childNodes = [];\n                    nodeArray = Array.prototype.slice.call(aNode.childNodes);\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        childNode = nodeArray[i];\n                        objNode.childNodes.push(dobj.nodeToObj(childNode));\n                    }\n                }\n                if (this.valueDiffing) {\n                    if (aNode.checked !== undefined && aNode.type &&\n                        ['radio','checkbox'].indexOf(aNode.type.toLowerCase()) !== -1\n                    ) {\n                        objNode.checked = aNode.checked;\n                    } else if (aNode.value !== undefined) {\n                        objNode.value = aNode.value;\n                    }\n                    if (aNode.selected !== undefined) {\n                        objNode.selected = aNode.selected;\n                    }\n                }\n            }\n            return objNode;\n        },\n        objToNode: function(objNode, insideSvg) {\n            var node, dobj = this,\n                attribute, attributeArray, childNode, childNodeArray, length, i;\n            if (objNode.nodeName === '#text') {\n                node = document.createTextNode(objNode.data);\n\n            } else if (objNode.nodeName === '#comment') {\n                node = document.createComment(objNode.data);\n            } else {\n                if (objNode.nodeName === 'svg' || insideSvg) {\n                    node = document.createElementNS('http://www.w3.org/2000/svg', objNode.nodeName);\n                    insideSvg = true;\n                } else {\n                    node = document.createElement(objNode.nodeName);\n                }\n                if (objNode.attributes) {\n                    attributeArray = Object.keys(objNode.attributes);\n                    length = attributeArray.length;\n                    for (i = 0; i < length; i++) {\n                        attribute = attributeArray[i];\n                        node.setAttribute(attribute, objNode.attributes[attribute]);\n                    }\n                }\n                if (objNode.childNodes) {\n                    childNodeArray = objNode.childNodes;\n                    length = childNodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        childNode = childNodeArray[i];\n                        node.appendChild(dobj.objToNode(childNode, insideSvg));\n                    }\n                }\n                if (this.valueDiffing) {\n                    if (objNode.value) {\n                        node.value = objNode.value;\n                    }\n                    if (objNode.checked) {\n                        node.checked = objNode.checked;\n                    }\n                    if (objNode.selected) {\n                        node.selected = objNode.selected;\n                    }\n                }\n            }\n            return node;\n        },\n        findInnerDiff: function(t1, t2, route) {\n            var oldSubsets = t1.subsets;\n            //var subtrees = (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n            var subtrees = t1.subsets && t1.subsetsAge-- ? t1.subsets : (t1.childNodes && t2.childNodes) ?  markSubTrees(t1, t2) : [],\n                t1ChildNodes = t1.childNodes ? t1.childNodes : [],\n                t2ChildNodes = t2.childNodes ? t2.childNodes : [],\n                childNodesLengthDifference, diffs = [],\n                index = 0, t = this,\n                last, e1, e2, i;\n\n            if (subtrees.length > 0) {\n                /* One or more groups have been identified among the childnodes of t1\n                 * and t2.\n                 */\n                diffs = this.attemptGroupRelocation(t1, t2, subtrees, route);\n                if (diffs.length > 0) {\n                    return diffs;\n                }\n            }\n\n            /* 0 or 1 groups of similar child nodes have been found\n             * for t1 and t2. 1 If there is 1, it could be a sign that the\n             * contents are the same. When the number of groups is below 2,\n             * t1 and t2 are made to have the same length and each of the\n             * pairs of child nodes are diffed.\n             */\n\n\n            last = Math.max(t1ChildNodes.length, t2ChildNodes.length);\n            if (t1ChildNodes.length !== t2ChildNodes.length) {\n                childNodesLengthDifference = true;\n            }\n\n            for (i = 0; i < last; i += 1) {\n                e1 = t1ChildNodes[i];\n                e2 = t2ChildNodes[i];\n\n                if (childNodesLengthDifference) {\n                    /* t1 and t2 have different amounts of childNodes. Add\n                     * and remove as necessary to obtain the same length */\n                    if (e1 && !e2) {\n                        if (e1.nodeName === '#text') {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.removeTextElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.value, e1.data)\n                            );\n                            index -= 1;\n                        } else {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.removeElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.element, cloneObj(e1))\n                            );\n                            index -= 1;\n                        }\n\n                    } else if (e2 && !e1) {\n                        if (e2.nodeName === '#text') {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.addTextElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.value, e2.data)\n                            );\n                        } else {\n                            diffs.push(new Diff()\n                                .setValue(t._const.action, t._const.addElement)\n                                .setValue(t._const.route, route.concat(index))\n                                .setValue(t._const.element, cloneObj(e2))\n                            );\n                        }\n                    }\n                }\n                /* We are now guaranteed that childNodes e1 and e2 exist,\n                 * and that they can be diffed.\n                 */\n                /* Diffs in child nodes should not affect the parent node,\n                 * so we let these diffs be submitted together with other\n                 * diffs.\n                 */\n\n                if (e1 && e2) {\n                    diffs = diffs.concat(this.findNextDiff(e1, e2, route.concat(index)));\n                }\n\n                index += 1;\n\n            }\n            t1.innerDone = true;\n            return diffs;\n\n        },\n\n        attemptGroupRelocation: function(t1, t2, subtrees, route) {\n            /* Either t1.childNodes and t2.childNodes have the same length, or\n             * there are at least two groups of similar elements can be found.\n             * attempts are made at equalizing t1 with t2. First all initial\n             * elements with no group affiliation (gaps=true) are removed (if\n             * only in t1) or added (if only in t2). Then the creation of a group\n             * relocation diff is attempted.\n             */\n            var t = this;\n            var gapInformation = getGapInformation(t1, t2, subtrees),\n                gaps1 = gapInformation.gaps1,\n                gaps2 = gapInformation.gaps2,\n                shortest = Math.min(gaps1.length, gaps2.length),\n                destinationDifferent, toGroup,\n                group, node, similarNode, testI, diffs = [],\n                index1, index2, j;\n\n\n            for (index2 = 0, index1 = 0; index2 < shortest; index1 += 1, index2 += 1) {\n                if (gaps1[index2] === true) {\n                    node = t1.childNodes[index1];\n                    if (node.nodeName === '#text') {\n                        if (t2.childNodes[index2].nodeName === '#text' && node.data !== t2.childNodes[index2].data) {\n                            testI = index1;\n                            while (t1.childNodes.length > testI + 1 && t1.childNodes[testI + 1].nodeName === '#text') {\n                                testI += 1;\n                                if (t2.childNodes[index2].data === t1.childNodes[testI].data) {\n                                    similarNode = true;\n                                    break;\n                                }\n                            }\n                            if (!similarNode) {\n                                diffs.push(new Diff()\n                                    .setValue(t._const.action, t._const.modifyTextElement)\n                                    .setValue(t._const.route, route.concat(index2))\n                                    .setValue(t._const.oldValue, node.data)\n                                    .setValue(t._const.newValue, t2.childNodes[index2].data)\n                                );\n                                return diffs;\n                            }\n                        }\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.removeTextElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.value, node.data)\n                        );\n                        gaps1.splice(index2, 1);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index2 -= 1;\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.removeElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.element, cloneObj(node))\n                        );\n                        gaps1.splice(index2, 1);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index2 -= 1;\n                    }\n\n                } else if (gaps2[index2] === true) {\n                    node = t2.childNodes[index2];\n                    if (node.nodeName === '#text') {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.addTextElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.value, node.data)\n                        );\n                        gaps1.splice(index2, 0, true);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index1 -= 1;\n                    } else {\n                        diffs.push(new Diff()\n                            .setValue(t._const.action, t._const.addElement)\n                            .setValue(t._const.route, route.concat(index2))\n                            .setValue(t._const.element, cloneObj(node))\n                        );\n                        gaps1.splice(index2, 0, true);\n                        shortest = Math.min(gaps1.length, gaps2.length);\n                        index1 -= 1;\n                    }\n\n                } else if (gaps1[index2] !== gaps2[index2]) {\n                    if (diffs.length > 0) {\n                        return diffs;\n                    }\n                    // group relocation\n                    group = subtrees[gaps1[index2]];\n                    toGroup = Math.min(group.newValue, (t1.childNodes.length - group.length));\n                    if (toGroup !== group.oldValue) {\n                        // Check whether destination nodes are different than originating ones.\n                        destinationDifferent = false;\n                        for (j = 0; j < group.length; j += 1) {\n                            if (!roughlyEqual(t1.childNodes[toGroup + j], t1.childNodes[group.oldValue + j], [], false, true)) {\n                                destinationDifferent = true;\n                            }\n                        }\n                        if (destinationDifferent) {\n                            return [new Diff()\n                                .setValue(t._const.action, t._const.relocateGroup)\n                                .setValue('groupLength', group.length)\n                                .setValue(t._const.from, group.oldValue)\n                                .setValue(t._const.to, toGroup)\n                                .setValue(t._const.route, route)\n                            ];\n                        }\n                    }\n                }\n            }\n            return diffs;\n        },\n\n        findValueDiff: function(t1, t2, route) {\n            // Differences of value. Only useful if the value/selection/checked value\n            // differs from what is represented in the DOM. For example in the case\n            // of filled out forms, etc.\n            var diffs = [];\n            var t = this;\n\n            if (t1.selected !== t2.selected) {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifySelected)\n                    .setValue(t._const.oldValue, t1.selected)\n                    .setValue(t._const.newValue, t2.selected)\n                    .setValue(t._const.route, route)\n                );\n            }\n\n            if ((t1.value || t2.value) && t1.value !== t2.value && t1.nodeName !== 'OPTION') {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifyValue)\n                    .setValue(t._const.oldValue, t1.value || \"\")\n                    .setValue(t._const.newValue, t2.value || \"\")\n                    .setValue(t._const.route, route)\n                );\n            }\n            if (t1.checked !== t2.checked) {\n                diffs.push(new Diff()\n                    .setValue(t._const.action, t._const.modifyChecked)\n                    .setValue(t._const.oldValue, t1.checked)\n                    .setValue(t._const.newValue, t2.checked)\n                    .setValue(t._const.route, route)\n                );\n            }\n\n            return diffs;\n        },\n\n        // ===== Apply a virtual diff =====\n\n        applyVirtual: function(tree, diffs) {\n            var dobj = this,\n                length = diffs.length,\n                diff, i;\n            if (length === 0) {\n                return true;\n            }\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                dobj.applyVirtualDiff(tree, diff);\n            }\n            return true;\n        },\n        getFromVirtualRoute: function(tree, route) {\n            var node = tree,\n                parentNode, nodeIndex;\n\n            route = route.slice();\n            while (route.length > 0) {\n                if (!node.childNodes) {\n                    return false;\n                }\n                nodeIndex = route.splice(0, 1)[0];\n                parentNode = node;\n                node = node.childNodes[nodeIndex];\n            }\n            return {\n                node: node,\n                parentNode: parentNode,\n                nodeIndex: nodeIndex\n            };\n        },\n        applyVirtualDiff: function(tree, diff) {\n            var routeInfo = this.getFromVirtualRoute(tree, diff[this._const.route]),\n                node = routeInfo.node,\n                parentNode = routeInfo.parentNode,\n                nodeIndex = routeInfo.nodeIndex,\n                newSubsets = [], splitLength,\n                newNode, movedNode, nodeArray, route, length, c, i;\n\n            var t = this;\n            // pre-diff hook\n            var info = {\n                diff: diff,\n                node: node\n            };\n\n            if (this.preVirtualDiffApply(info)) {\n                return true;\n            }\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    if (!node.attributes) {\n                        node.attributes = {};\n                    }\n\n                    node.attributes[diff[this._const.name]] = diff[this._const.value];\n\n                    if (diff[this._const.name] === 'checked') {\n                        node.checked = true;\n                    } else if (diff[this._const.name] === 'selected') {\n                        node.selected = true;\n                    } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                        node.value = diff[this._const.value];\n                    }\n\n                    break;\n                case this._const.modifyAttribute:\n                    node.attributes[diff[this._const.name]] = diff[this._const.newValue];\n                    break;\n                case this._const.removeAttribute:\n\n                    delete node.attributes[diff[this._const.name]];\n\n                    if (Object.keys(node.attributes).length === 0) {\n                        delete node.attributes;\n                    }\n\n                    if (diff[this._const.name] === 'checked') {\n                        node.checked = false;\n                    } else if (diff[this._const.name] === 'selected') {\n                        delete node.selected;\n                    } else if (node.nodeName === 'INPUT' && diff[this._const.name] === 'value') {\n                        delete node.value;\n                    }\n\n                    break;\n                case this._const.modifyTextElement:\n                    node.data = diff[this._const.newValue];\n                    break;\n                case this._const.modifyValue:\n                    node.value = diff[this._const.newValue];\n                    break;\n                case this._const.modifyComment:\n                    node.data = diff[this._const.newValue];\n                    break;\n                case this._const.modifyChecked:\n                    node.checked = diff[this._const.newValue];\n                    break;\n                case this._const.modifySelected:\n                    node.selected = diff[this._const.newValue];\n                    break;\n                case this._const.replaceElement:\n                    newNode = cloneObj(diff[this._const.newValue]);\n                    newNode.outerDone = true;\n                    newNode.innerDone = true;\n                    newNode.valueDone = true;\n                    parentNode.childNodes[nodeIndex] = newNode;\n                    break;\n                case this._const.relocateGroup:\n                    nodeArray = node.childNodes.splice(diff[this._const.from], diff.groupLength).reverse();\n                    length = nodeArray.length;\n                    for (i = 0; i < length; i++) {\n                        movedNode = nodeArray[i];\n                        node.childNodes.splice(diff[t._const.to], 0, movedNode);\n                    }\n                    if (node.subsets) {\n\n                        node.subsets.forEach(function(map) {\n                            if (diff[t._const.from] < diff[t._const.to] && map.oldValue <= diff[t._const.to] && map.oldValue > diff[t._const.from]) {\n                                map.oldValue -= diff.groupLength;\n                                splitLength = map.oldValue + map.length - diff[t._const.to];\n                                if (splitLength > 0) {\n                                    // new insertion splits map.\n                                    newSubsets.push({\n                                        oldValue: diff[t._const.to] + diff.groupLength,\n                                        newValue: map.newValue + map.length - splitLength,\n                                        length: splitLength\n                                    })\n                                    map.length -= splitLength;\n                                }\n                            } else if (diff[t._const.from] > diff[t._const.to] && map.oldValue > diff[t._const.to] && map.oldValue < diff[t._const.from]) {\n                                map.oldValue += diff.groupLength;\n                                splitLength = map.oldValue + map.length - diff[t._const.to];\n                                if (splitLength > 0) {\n                                    // new insertion splits map.\n                                    newSubsets.push({\n                                        oldValue: diff[t._const.to] + diff.groupLength,\n                                        newValue: map.newValue + map.length - splitLength,\n                                        length: splitLength\n                                    })\n                                    map.length -= splitLength;\n                                }\n                            } else if (map.oldValue === diff[t._const.from]) {\n                                map.oldValue = diff[t._const.to];\n                            }\n                        });\n                    }\n\n                    break;\n                case this._const.removeElement:\n                    parentNode.childNodes.splice(nodeIndex, 1);\n                    if (parentNode.subsets) {\n                        parentNode.subsets.forEach(function(map) {\n                            if (map.oldValue > nodeIndex) {\n                                map.oldValue -= 1;\n                            } else if (map.oldValue === nodeIndex) {\n                                map.delete = true;\n                            } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                                if (map.oldValue + map.length - 1 === nodeIndex) {\n                                    map.length--;\n                                } else {\n                                    newSubsets.push({\n                                        newValue: map.newValue + nodeIndex - map.oldValue,\n                                        oldValue: nodeIndex,\n                                        length: map.length - nodeIndex + map.oldValue - 1\n                                    })\n                                    map.length = nodeIndex - map.oldValue\n                                }\n                            }\n                        });\n                    }\n                    node = parentNode;\n                    break;\n                case this._const.addElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    node = this.getFromVirtualRoute(tree, route).node;\n                    newNode = cloneObj(diff[this._const.element]);\n                    newNode.outerDone = true;\n                    newNode.innerDone = true;\n                    newNode.valueDone = true;\n\n                    if (!node.childNodes) {\n                        node.childNodes = [];\n                    }\n\n                    if (c >= node.childNodes.length) {\n                        node.childNodes.push(newNode);\n                    } else {\n                        node.childNodes.splice(c, 0, newNode);\n                    }\n                    if (node.subsets) {\n                        node.subsets.forEach(function(map) {\n                            if (map.oldValue >= c) {\n                                map.oldValue += 1;\n                            } else if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                                splitLength = map.oldValue + map.length - c\n                                newSubsets.push({\n                                    newValue: map.newValue + map.length - splitLength,\n                                    oldValue: c + 1,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        });\n                    }\n                    break;\n                case this._const.removeTextElement:\n                    parentNode.childNodes.splice(nodeIndex, 1);\n                    if (parentNode.nodeName === 'TEXTAREA') {\n                        delete parentNode.value;\n                    }\n                    if (parentNode.subsets) {\n                        parentNode.subsets.forEach(function(map) {\n                            if (map.oldValue > nodeIndex) {\n                                map.oldValue -= 1;\n                            } else if (map.oldValue === nodeIndex) {\n                                map.delete = true;\n                            } else if (map.oldValue < nodeIndex && (map.oldValue + map.length) > nodeIndex) {\n                                if (map.oldValue + map.length - 1 === nodeIndex) {\n                                    map.length--;\n                                } else {\n                                    newSubsets.push({\n                                        newValue: map.newValue + nodeIndex - map.oldValue,\n                                        oldValue: nodeIndex,\n                                        length: map.length - nodeIndex + map.oldValue - 1\n                                    })\n                                    map.length = nodeIndex - map.oldValue\n                                }\n                            }\n                        });\n                    }\n                    node = parentNode;\n                    break;\n                case this._const.addTextElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    newNode = {};\n                    newNode.nodeName = '#text';\n                    newNode.data = diff[this._const.value];\n                    node = this.getFromVirtualRoute(tree, route).node;\n                    if (!node.childNodes) {\n                        node.childNodes = [];\n                    }\n\n                    if (c >= node.childNodes.length) {\n                        node.childNodes.push(newNode);\n                    } else {\n                        node.childNodes.splice(c, 0, newNode);\n                    }\n                    if (node.nodeName === 'TEXTAREA') {\n                        node.value = diff[this._const.newValue];\n                    }\n                    if (node.subsets) {\n                        node.subsets.forEach(function(map) {\n                            if (map.oldValue >= c) {\n                                map.oldValue += 1;\n                            } if (map.oldValue < c && (map.oldValue + map.length) > c) {\n                                splitLength = map.oldValue + map.length - c\n                                newSubsets.push({\n                                    newValue: map.newValue + map.length - splitLength,\n                                    oldValue: c + 1,\n                                    length: splitLength\n                                })\n                                map.length -= splitLength\n                            }\n                        });\n                    }\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n            if (node.subsets) {\n                node.subsets = node.subsets.filter(function(map) {\n                    return !map.delete && map.oldValue !== map.newValue;\n                });\n                if (newSubsets.length) {\n                    node.subsets = node.subsets.concat(newSubsets);\n                }\n            }\n\n            // capture newNode for the callback\n            info.newNode = newNode;\n            this.postVirtualDiffApply(info);\n\n            return;\n        },\n\n\n\n\n        // ===== Apply a diff =====\n\n        apply: function(tree, diffs) {\n            var dobj = this,\n                length = diffs.length,\n                diff, i;\n\n            if (length === 0) {\n                return true;\n            }\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                if (!dobj.applyDiff(tree, diff)) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        getFromRoute: function(tree, route) {\n            route = route.slice();\n            var c, node = tree;\n            while (route.length > 0) {\n                if (!node.childNodes) {\n                    return false;\n                }\n                c = route.splice(0, 1)[0];\n                node = node.childNodes[c];\n            }\n            return node;\n        },\n        applyDiff: function(tree, diff) {\n            var node = this.getFromRoute(tree, diff[this._const.route]),\n                newNode, reference, route, nodeArray, length, childNode, index, c;\n\n            var t = this;\n            // pre-diff hook\n            var info = {\n                diff: diff,\n                node: node\n            };\n\n            if (this.preDiffApply(info)) {\n                return true;\n            }\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    if (!node || !node.setAttribute) {\n                        return false;\n                    }\n                    node.setAttribute(diff[this._const.name], diff[this._const.value]);\n                    break;\n                case this._const.modifyAttribute:\n                    if (!node || !node.setAttribute) {\n                        return false;\n                    }\n                    node.setAttribute(diff[this._const.name], diff[this._const.newValue]);\n                    if (diff[this._const.name] === 'value' && node.nodeName === 'INPUT' && node.value !== diff[this._const.oldValue]) {\n                        node.value = diff[this._const.oldValue];\n                    }\n                    break;\n                case this._const.removeAttribute:\n                    if (!node || !node.removeAttribute) {\n                        return false;\n                    }\n                    node.removeAttribute(diff[this._const.name]);\n                    break;\n                case this._const.modifyTextElement:\n                    if (!node || node.nodeType !== 3) {\n                        return false;\n                    }\n                    this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue]);\n                    break;\n                case this._const.modifyValue:\n                    if (!node || typeof node.value === 'undefined') {\n                        return false;\n                    }\n                    node.value = diff[this._const.newValue];\n                    break;\n                case this._const.modifyComment:\n                    if (!node || typeof node.data === 'undefined') {\n                        return false;\n                    }\n                    this.textDiff(node, node.data, diff[this._const.oldValue], diff[this._const.newValue]);\n                    break;\n                case this._const.modifyChecked:\n                    if (!node || typeof node.checked === 'undefined') {\n                        return false;\n                    }\n                    node.checked = diff[this._const.newValue];\n                    break;\n                case this._const.modifySelected:\n                    if (!node || typeof node.selected === 'undefined') {\n                        return false;\n                    }\n                    node.selected = diff[this._const.newValue];\n                    break;\n                case this._const.replaceElement:\n                    node.parentNode.replaceChild(this.objToNode(diff[this._const.newValue], node.namespaceURI === 'http://www.w3.org/2000/svg'), node);\n                    break;\n                case this._const.relocateGroup:\n                    nodeArray = Array.apply(null, new Array(diff.groupLength)).map(function() {\n                        return node.removeChild(node.childNodes[diff[t._const.from]]);\n                    });\n                    length = nodeArray.length;\n                    for (index = 0; index < length; index++) {\n                        childNode = nodeArray[index];\n                        if (index === 0) {\n                            reference = node.childNodes[diff[t._const.to]];\n                        }\n                        node.insertBefore(childNode, reference || null);\n                    }\n                    break;\n                case this._const.removeElement:\n                    node.parentNode.removeChild(node);\n                    break;\n                case this._const.addElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    node = this.getFromRoute(tree, route);\n                    node.insertBefore(this.objToNode(diff[this._const.element], node.namespaceURI === 'http://www.w3.org/2000/svg'), node.childNodes[c] || null);\n                    break;\n                case this._const.removeTextElement:\n                    if (!node || node.nodeType !== 3) {\n                        return false;\n                    }\n                    node.parentNode.removeChild(node);\n                    break;\n                case this._const.addTextElement:\n                    route = diff[this._const.route].slice();\n                    c = route.splice(route.length - 1, 1)[0];\n                    newNode = document.createTextNode(diff[this._const.value]);\n                    node = this.getFromRoute(tree, route);\n                    if (!node || !node.childNodes) {\n                        return false;\n                    }\n                    node.insertBefore(newNode, node.childNodes[c] || null);\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n            // if a new node was created, we might be interested in it\n            // post diff hook\n            info.newNode = newNode;\n            this.postDiffApply(info);\n\n            return true;\n        },\n\n        // ===== Undo a diff =====\n\n        undo: function(tree, diffs) {\n            var dobj = this, diff, length = diffs.length, i;\n            diffs = diffs.slice();\n            if (!length) {\n                diffs = [diffs];\n            }\n            diffs.reverse();\n            for (i = 0; i < length; i++) {\n                diff = diffs[i];\n                dobj.undoDiff(tree, diff);\n            }\n        },\n        undoDiff: function(tree, diff) {\n\n            switch (diff[this._const.action]) {\n                case this._const.addAttribute:\n                    diff[this._const.action] = this._const.removeAttribute;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyAttribute:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeAttribute:\n                    diff[this._const.action] = this._const.addAttribute;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyTextElement:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyValue:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyComment:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifyChecked:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.modifySelected:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.replaceElement:\n                    swap(diff, this._const.oldValue, this._const.newValue);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.relocateGroup:\n                    swap(diff, this._const.from, this._const.to);\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeElement:\n                    diff[this._const.action] = this._const.addElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.addElement:\n                    diff[this._const.action] = this._const.removeElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.removeTextElement:\n                    diff[this._const.action] = this._const.addTextElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                case this._const.addTextElement:\n                    diff[this._const.action] = this._const.removeTextElement;\n                    this.applyDiff(tree, diff);\n                    break;\n                default:\n                    console.log('unknown action');\n            }\n\n        }\n    };\n\n    return diffDOM;\n});\n\n\n//# sourceURL=webpack:///./node_modules/diff-dom/diffDOM.js?");

/***/ }),

/***/ "./node_modules/marked/lib/marked.js":
/*!*******************************************!*\
  !*** ./node_modules/marked/lib/marked.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * marked - a markdown parser\n * Copyright (c) 2011-2018, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n;(function(root) {\n'use strict';\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *(?:#+ *)?(?:\\n+|$)/,\n  nptable: noop,\n  blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?\\\\?>\\\\n*' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?>\\\\n*' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\\\\n*' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=\\\\h*\\\\n)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=\\\\h*\\\\n)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n  def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n  table: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading| {0,3}>|<\\/?(?:tag)(?: +|\\n|\\/?>)|<(?:script|pre|style|!--))[^\\n]+)*)/,\n  text: /^[^\\n]+/\n};\n\nblock._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\nblock._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\nblock.def = edit(block.def)\n  .replace('label', block._label)\n  .replace('title', block._title)\n  .getRegex();\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = edit(block.item, 'gm')\n  .replace(/bull/g, block.bullet)\n  .getRegex();\n\nblock.list = edit(block.list)\n  .replace(/bull/g, block.bullet)\n  .replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))')\n  .replace('def', '\\\\n+(?=' + block.def.source + ')')\n  .getRegex();\n\nblock._tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'\n  + '|track|ul';\nblock._comment = /<!--(?!-?>)[\\s\\S]*?-->/;\nblock.html = edit(block.html, 'i')\n  .replace('comment', block._comment)\n  .replace('tag', block._tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nblock.paragraph = edit(block.paragraph)\n  .replace('hr', block.hr)\n  .replace('heading', block.heading)\n  .replace('lheading', block.lheading)\n  .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nblock.blockquote = edit(block.blockquote)\n  .replace('paragraph', block.paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? *\\n([\\s\\S]*?)\\n? *\\1 *(?:\\n+|$)/,\n  paragraph: /^/,\n  heading: /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/\n});\n\nblock.gfm.paragraph = edit(block.paragraph)\n  .replace('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  .getRegex();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:.*[^>\\n ].*(?:\\n|$))*)\\n*|$)/,\n  table: /^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n((?: *[^>\\n ].*(?:\\n|$))*)\\n*|$)/\n});\n\n/**\n * Pedantic grammar\n */\n\nblock.pedantic = merge({}, block.normal, {\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', block._comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = Object.create(null);\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.pedantic) {\n    this.rules = block.pedantic;\n  } else if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top) {\n  src = src.replace(/^ +$/gm, '');\n  var next,\n      loose,\n      cap,\n      bull,\n      b,\n      item,\n      listStart,\n      listItems,\n      t,\n      space,\n      i,\n      tag,\n      l,\n      isordered,\n      istask,\n      ischecked;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? rtrim(cap, '\\n')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3] || ''\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length);\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(item.cells[i], item.header.length);\n        }\n\n        this.tokens.push(item);\n\n        continue;\n      }\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n      isordered = bull.length > 1;\n\n      listStart = {\n        type: 'list_start',\n        ordered: isordered,\n        start: isordered ? +bull : '',\n        loose: false\n      };\n\n      this.tokens.push(listStart);\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      listItems = [];\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        if (loose) {\n          listStart.loose = true;\n        }\n\n        // Check for task list items\n        istask = /^\\[[ xX]\\] /.test(item);\n        ischecked = undefined;\n        if (istask) {\n          ischecked = item[1] !== ' ';\n          item = item.replace(/^\\[[ xX]\\] +/, '');\n        }\n\n        t = {\n          type: 'list_item_start',\n          task: istask,\n          checked: ischecked,\n          loose: loose\n        };\n\n        listItems.push(t);\n        this.tokens.push(t);\n\n        // Recurse.\n        this.token(item, false);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      if (listStart.loose) {\n        l = listItems.length;\n        i = 0;\n        for (; i < l; i++) {\n          listItems[i].loose = true;\n        }\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: !this.options.sanitizer\n          && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if (top && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n      tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n      if (!this.tokens.links[tag]) {\n        this.tokens.links[tag] = {\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      item = {\n        type: 'table',\n        header: splitCells(cap[1].replace(/^ *| *\\| *$/g, '')),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3] ? cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n') : []\n      };\n\n      if (item.header.length === item.align.length) {\n        src = src.substring(cap[0].length);\n\n        for (i = 0; i < item.align.length; i++) {\n          if (/^ *-+: *$/.test(item.align[i])) {\n            item.align[i] = 'right';\n          } else if (/^ *:-+: *$/.test(item.align[i])) {\n            item.align[i] = 'center';\n          } else if (/^ *:-+ *$/.test(item.align[i])) {\n            item.align[i] = 'left';\n          } else {\n            item.align[i] = null;\n          }\n        }\n\n        for (i = 0; i < item.cells.length; i++) {\n          item.cells[i] = splitCells(\n            item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''),\n            item.header.length);\n        }\n\n        this.tokens.push(item);\n\n        continue;\n      }\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n  url: noop,\n  tag: '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>', // CDATA section\n  link: /^!?\\[(label)\\]\\(href(?:\\s+(title))?\\s*\\)/,\n  reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n  nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n  strong: /^__([^\\s])__(?!_)|^\\*\\*([^\\s])\\*\\*(?!\\*)|^__([^\\s][\\s\\S]*?[^\\s])__(?!_)|^\\*\\*([^\\s][\\s\\S]*?[^\\s])\\*\\*(?!\\*)/,\n  em: /^_([^\\s_])_(?!_)|^\\*([^\\s*\"<\\[])\\*(?!\\*)|^_([^\\s][\\s\\S]*?[^\\s_])_(?!_|[^\\s.])|^_([^\\s_][\\s\\S]*?[^\\s])_(?!_|[^\\s.])|^\\*([^\\s\"<\\[][\\s\\S]*?[^\\s*])\\*(?!\\*)|^\\*([^\\s*\"<\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,\n  code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n  br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n  del: noop,\n  text: /^(`+|[^`])[\\s\\S]*?(?=[\\\\<!\\[`*]|\\b_| {2,}\\n|$)/\n};\n\ninline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n\ninline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\ninline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\ninline.autolink = edit(inline.autolink)\n  .replace('scheme', inline._scheme)\n  .replace('email', inline._email)\n  .getRegex();\n\ninline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n\ninline.tag = edit(inline.tag)\n  .replace('comment', block._comment)\n  .replace('attribute', inline._attribute)\n  .getRegex();\n\ninline._label = /(?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]?|`[^`]*`|[^\\[\\]\\\\])*?/;\ninline._href = /\\s*(<(?:\\\\[<>]?|[^\\s<>\\\\])*>|(?:\\\\[()]?|\\([^\\s\\x00-\\x1f\\\\]*\\)|[^\\s\\x00-\\x1f()\\\\])*?)/;\ninline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n\ninline.link = edit(inline.link)\n  .replace('label', inline._label)\n  .replace('href', inline._href)\n  .replace('title', inline._title)\n  .getRegex();\n\ninline.reflink = edit(inline.reflink)\n  .replace('label', inline._label)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', inline._label)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', inline._label)\n    .getRegex()\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: edit(inline.escape).replace('])', '~|])').getRegex(),\n  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n  url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n  _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n  del: /^~+(?=\\S)([\\s\\S]*?\\S)~+/,\n  text: edit(inline.text)\n    .replace(']|', '~]|')\n    .replace('|$', '|https?://|ftp://|www\\\\.|[a-zA-Z0-9.!#$%&\\'*+/=?^_`{\\\\|}~-]+@|$')\n    .getRegex()\n});\n\ninline.gfm.url = edit(inline.gfm.url)\n  .replace('email', inline.gfm._extended_email)\n  .getRegex();\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: edit(inline.br).replace('{2,}', '*').getRegex(),\n  text: edit(inline.gfm.text).replace('{2,}', '*').getRegex()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer();\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  } else if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = '',\n      link,\n      text,\n      href,\n      title,\n      cap,\n      prevCapZero;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = escape(this.mangle(cap[1]));\n        href = 'mailto:' + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      if (cap[2] === '@') {\n        text = escape(cap[0]);\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules._backpedal.exec(cap[0])[0];\n        } while (prevCapZero !== cap[0]);\n        text = escape(cap[0]);\n        if (cap[1] === 'www.') {\n          href = 'http://' + text;\n        } else {\n          href = text;\n        }\n      }\n      src = src.substring(cap[0].length);\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      if (!this.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.inRawBlock = true;\n      } else if (this.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n        this.inRawBlock = false;\n      }\n\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? this.options.sanitizer\n          ? this.options.sanitizer(cap[0])\n          : escape(cap[0])\n        : cap[0];\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      href = cap[2];\n      if (this.options.pedantic) {\n        link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        } else {\n          title = '';\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n      href = href.trim().replace(/^<([\\s\\S]*)>$/, '$1');\n      out += this.outputLink(cap, {\n        href: InlineLexer.escapes(href),\n        title: InlineLexer.escapes(title)\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2].trim(), true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (this.inRawBlock) {\n        out += this.renderer.text(cap[0]);\n      } else {\n        out += this.renderer.text(escape(this.smartypants(cap[0])));\n      }\n      continue;\n    }\n\n    if (src) {\n      throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\nInlineLexer.escapes = function(text) {\n  return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = link.href,\n      title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/---/g, '\\u2014')\n    // en-dashes\n    .replace(/--/g, '\\u2013')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  if (!this.options.mangle) return text;\n  var out = '',\n      l = text.length,\n      i = 0,\n      ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || marked.defaults;\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  if (this.options.headerIds) {\n    return '<h'\n      + level\n      + ' id=\"'\n      + this.options.headerPrefix\n      + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n      + '\">'\n      + text\n      + '</h'\n      + level\n      + '>\\n';\n  }\n  // ignore IDs\n  return '<h' + level + '>' + text + '</h' + level + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered, start) {\n  var type = ordered ? 'ol' : 'ul',\n      startatt = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n  return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.checkbox = function(checked) {\n  return '<input '\n    + (checked ? 'checked=\"\" ' : '')\n    + 'disabled=\"\" type=\"checkbox\"'\n    + (this.options.xhtml ? ' /' : '')\n    + '> ';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  if (body) body = '<tbody>' + body + '</tbody>';\n\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + body\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' align=\"' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n  if (href === null) {\n    return text;\n  }\n  var out = '<a href=\"' + escape(href) + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);\n  if (href === null) {\n    return text;\n  }\n\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\nRenderer.prototype.text = function(text) {\n  return text;\n};\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\n\nfunction TextRenderer() {}\n\n// no need for block level renderers\n\nTextRenderer.prototype.strong =\nTextRenderer.prototype.em =\nTextRenderer.prototype.codespan =\nTextRenderer.prototype.del =\nTextRenderer.prototype.text = function (text) {\n  return text;\n};\n\nTextRenderer.prototype.link =\nTextRenderer.prototype.image = function(href, title, text) {\n  return '' + text;\n};\n\nTextRenderer.prototype.br = function() {\n  return '';\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer();\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options) {\n  var parser = new Parser(options);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options);\n  // use an InlineLexer with a TextRenderer to extract pure text\n  this.inlineText = new InlineLexer(\n    src.links,\n    merge({}, this.options, {renderer: new TextRenderer()})\n  );\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        unescape(this.inlineText.output(this.token.text)));\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = '',\n          body = '',\n          i,\n          row,\n          cell,\n          j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      body = '';\n      var ordered = this.token.ordered,\n          start = this.token.start;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered, start);\n    }\n    case 'list_item_start': {\n      body = '';\n      var loose = this.token.loose;\n\n      if (this.token.task) {\n        body += this.renderer.checkbox(this.token.checked);\n      }\n\n      while (this.next().type !== 'list_item_end') {\n        body += !loose && this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      // TODO parse inline content if parameter markdown=1\n      return this.renderer.html(this.token.text);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  if (encode) {\n    if (escape.escapeTest.test(html)) {\n      return html.replace(escape.escapeReplace, function (ch) { return escape.replacements[ch]; });\n    }\n  } else {\n    if (escape.escapeTestNoEncode.test(html)) {\n      return html.replace(escape.escapeReplaceNoEncode, function (ch) { return escape.replacements[ch]; });\n    }\n  }\n\n  return html;\n}\n\nescape.escapeTest = /[&<>\"']/;\nescape.escapeReplace = /[&<>\"']/g;\nescape.replacements = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\n\nescape.escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\nescape.escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n\nfunction unescape(html) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction edit(regex, opt) {\n  regex = regex.source || regex;\n  opt = opt || '';\n  return {\n    replace: function(name, val) {\n      val = val.source || val;\n      val = val.replace(/(^|[^\\[])\\^/g, '$1');\n      regex = regex.replace(name, val);\n      return this;\n    },\n    getRegex: function() {\n      return new RegExp(regex, opt);\n    }\n  };\n}\n\nfunction cleanUrl(sanitize, base, href) {\n  if (sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return null;\n    }\n    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n      return null;\n    }\n  }\n  if (base && !originIndependentUrl.test(href)) {\n    href = resolveUrl(base, href);\n  }\n  try {\n    href = encodeURI(href).replace(/%25/g, '%');\n  } catch (e) {\n    return null;\n  }\n  return href;\n}\n\nfunction resolveUrl(base, href) {\n  if (!baseUrls[' ' + base]) {\n    // we can ignore everything in base after the last slash of its path component,\n    // but we might need to add _that_\n    // https://tools.ietf.org/html/rfc3986#section-3\n    if (/^[^:]+:\\/*[^/]*$/.test(base)) {\n      baseUrls[' ' + base] = base + '/';\n    } else {\n      baseUrls[' ' + base] = rtrim(base, '/', true);\n    }\n  }\n  base = baseUrls[' ' + base];\n\n  if (href.slice(0, 2) === '//') {\n    return base.replace(/:[\\s\\S]*/, ':') + href;\n  } else if (href.charAt(0) === '/') {\n    return base.replace(/(:\\/*[^/]*)[\\s\\S]*/, '$1') + href;\n  } else {\n    return base + href;\n  }\n}\nvar baseUrls = {};\nvar originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1,\n      target,\n      key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nfunction splitCells(tableRow, count) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n        var escaped = false,\n            curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n        if (escaped) {\n          // odd number of slashes means | is escaped\n          // so we leave it alone\n          return '|';\n        } else {\n          // add space before unescaped |\n          return ' |';\n        }\n      }),\n      cells = row.split(/ \\|/),\n      i = 0;\n\n  if (cells.length > count) {\n    cells.splice(count);\n  } else {\n    while (cells.length < count) cells.push('');\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n  }\n  return cells;\n}\n\n// Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n// /c*$/ is vulnerable to REDOS.\n// invert: Remove suffix of non-c chars instead. Default falsey.\nfunction rtrim(str, c, invert) {\n  if (str.length === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  var suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < str.length) {\n    var currChar = str.charAt(str.length - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.substr(0, str.length - suffLen);\n}\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  // throw error in case of non string input\n  if (typeof src === 'undefined' || src === null) {\n    throw new Error('marked(): input parameter is undefined or null');\n  }\n  if (typeof src !== 'string') {\n    throw new Error('marked(): input parameter is of type '\n      + Object.prototype.toString.call(src) + ', string expected');\n  }\n\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight,\n        tokens,\n        pending,\n        i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt);\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function(err) {\n      if (err) {\n        opt.highlight = highlight;\n        return callback(err);\n      }\n\n      var out;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (err) return done(err);\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occurred:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.getDefaults = function () {\n  return {\n    baseUrl: null,\n    breaks: false,\n    gfm: true,\n    headerIds: true,\n    headerPrefix: '',\n    highlight: null,\n    langPrefix: 'language-',\n    mangle: true,\n    pedantic: false,\n    renderer: new Renderer(),\n    sanitize: false,\n    sanitizer: null,\n    silent: false,\n    smartLists: false,\n    smartypants: false,\n    tables: true,\n    xhtml: false\n  };\n};\n\nmarked.defaults = marked.getDefaults();\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\nmarked.TextRenderer = TextRenderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (true) {\n  module.exports = marked;\n} else {}\n})(this || (typeof window !== 'undefined' ? window : global));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/marked/lib/marked.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ })

/******/ });